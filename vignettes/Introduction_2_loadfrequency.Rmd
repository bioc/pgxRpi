---
title: "Introduction_2_loadfrequency"
author: "Hangjia Zhao"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction_2_loadfrequency}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Load library 

```{r setup}
library(pgxRpi)
```

## `pgxLoader` function in this package

This function loads various data from `Progenetix` database.  

The parameters of this function:

* `type` A string specifying output data type. Available options are "biosample", 
"variant" or "frequency". 
* `output` A string specifying output file format. Available options are NULL, 
'pgxseg' or 'seg' when the parameter `type` is "variant"; 'pgxseg' or 'pgxmatrix' 
when the parameter `type` is "frequency".
* `filters` A single or a comma-concatenated list of identifiers for cancer type,
literature, and cohorts such as c("NCIT:C7376","pgx:icdom-98353","PMID:22824167", "pgx:cohort-TCGAcancers").
Only used if the parameter `type` is "biosample" or "frequency".
* `codematches` A logical value determining whether to exclude samples 
from child terms of specified filters. If FALSE, retrieved samples include child 
terms of specified filters. Only used when `filters` is specified. Default is FALSE.
* `limit` An integer value to specify the number of returned profiles. Only used when the parameter `type` is "variant" and `output` is "pgxmatrix".
* `skip` An Integer value to specify the number of skipped profiles. Only used when the parameter `type` is "variant" and `output` is "pgxmatrix".
* `biosample_id` A single or a comma-concatenated list of identifiers used in Progenetix 
database for identifying biosamples. 
* `save_file` A logical value determining whether to save the variant data as file 
instead of direct return. Only used when the parameter `type` is "variant". Default is FALSE.
* `filename` A string specifying the path and name of the file to be saved. 
Only used if the parameter `save_file` is TRUE. Default is "variants.seg/pgxseg" in current work directory.

# Retrieve CNV frequency data

Relevant parameters of `pgxLoader` function: type, output, filters, codematches

There are two output formats

## The first output format (`output` = "pgxseg")

```{r}
freq_pgxseg <- pgxLoader(type="frequency", output ='pgxseg',
                         filters=c("NCIT:C4038","pgx:icdom-85003"), 
                         codematches = TRUE)
```

The parameter `codematches` determines whether the calculation of CNV frequency excludes samples from child terms.

The `meta` slot of this object looks like this

```{r}
freq_pgxseg$meta
```
The `data` slot contains a list of the CNV frequency data frames named by the corresponding 
filters. The data frame with the name 'total' is the concatenated data frames from all 
filters.

```{r}
names(freq_pgxseg$data)
```

You can access the data frame with "pgxseg" format of one filter from this list.  

```{r}
head(freq_pgxseg$data[['NCIT:C4038']])
```

In the pgxseg format, 

* `filters`: identifiers for grouping. 
* `reference_name`, `start` and `end` specify interval location in chromosome.
* `gain_frequency` and `loss_frequency` indicate the percent values for gains and 
losses overlapping the interval, respectively


## The second output format (`output` = "pgxmatrix")

Choose 8 NCIT codes of interests that correspond to different tumor types

```{r}
code <-c("C3059","C3716","C4917","C3512","C3493","C3771","C4017","C4001")
# add prefix for query
code <- sub(".",'NCIT:C',code)
```

load data with the specified code

```{r}
freq_pgxmatrix <- pgxLoader(type='frequency',output = 'pgxmatrix',filters=code,codematches=TRUE)
```

The `meta` slot of this object looks like this

```{r}
freq_pgxmatrix$meta
```

The `data` slot contains a list of the nine CNV frequency data frames. One of these nine
data frames looks like this

```{r}
freq_pgxmatrix$data[['NCIT:C3059']][,c(1:4,3108:3110)]
```

In the data frame with "pgxmatrix" format, `filters` is the same as that in the "pgxseg" format. It's followed by all “gain status” columns (3106 intervals) plus all “loss status” columns (3106 intervals). Note: it is different from CNV status matrix introduced in Introduction_1. Value in this matrix is calculated across samples while the value in CNV status matrix is overlapped coverage in individual samples.

You can also access the total data frame for analyzing multiple frequency sets.

```{r}
freq_pgxmatrix$data[['total']][,c(1:4,3108:3110)]
```

# Select ids of interests from original object of CNV frequency

It is realized by `pgxFreqselect` function.

This function can select filters of interests from input object and return a new object 
with selected filters.

The parameters of this function:

* `data`: CNV frequency data returned by `pgxLoader` function. 
* `filters`: identifiers of interests such as c("NCIT:C7376","pgx:icdom-98353").

```{r}
freq_sel <- pgxFreqselect(data=freq_pgxmatrix, 
                          filters = c("NCIT:C4917","NCIT:C3512","NCIT:C3493"))
freq_sel$data$total[,c(1:5)]
```
# Visualization of CNV frequency data using 'pgxseg' format

## `pgxFeqplot` function

This function provides CNV frequency plots by genome or chromosomes as you request.

The parameters of this function:

* `data`: frequency data returned by `pgxLoader` function. The frequency matrices in `data` 
slot must be stored as `.pgxseg` format, which can be specified by `output` parameter of `pgxLoader` function.   
* `chrom`: a vector with chromosomes to be plotted. If NULL, return the plot by genome. If specified the frequencies are plotted with one panel for each chromosome. Default is NULL.
* `layout`: number of columns and rows in plot. Only used in plot by chromosome. Default is c(1,1). 
* `filters`: Index or string value to indicate which filter to be plotted. The length of filters is limited to one if the parameter `circos` is False. Default is the first filter.
* `circos`: a logical value to indicate if return a circos plot. If TRUE, it can 
return a circos plot with multiple group ids for display and comparison. Default is FALSE.

### CNV frequency plot by genome (GRCh38)

```{r, fig.width=7, fig.height=5}
pgxFreqplot(freq_pgxseg, filters='pgx:icdom-85003')
```

### CNV frequency plot by chromosomes

```{r, fig.width=7, fig.height=5}
pgxFreqplot(freq_pgxseg, filters='NCIT:C4038',chrom=c(1,2,3), layout = c(3,1))  
```

### CNV frequency circos plot 

```{r,fig.width=6, fig.height=6}
pgxFreqplot(freq_pgxseg, filters='pgx:icdom-85003', circos = TRUE)
```

The circos plot also supports multiple group comparison

```{r,fig.width=6, fig.height=6}
pgxFreqplot(freq_pgxseg,filters= c("NCIT:C4038","pgx:icdom-85003"),circos = TRUE) 
```

# Clustering of CNV frequency data using 'pgxmatrix' format

## Hierarchical clustering

Use hierarchical clustering to cluster the tumor types which are picked before by NCIt code.

```{r}
# extract CNV frequency data from `total` slot
freq_mat <- freq_pgxmatrix$data[['total']][,2:dim(freq_pgxmatrix$data[['total']])[2]]
rownames(freq_mat) <- freq_pgxmatrix$data[['total']]$filters
# do clustering
dist_mat <- dist(freq_mat, method = 'euclidean')
hclust_res <- hclust(dist_mat, method = "ward.D")
```

The clustering result is shown below. 

```{r}
hcd <- as.dendrogram(hclust_res)
plot(hcd, type = "rectangle", ylab = "Height")
# Based on the plot, the number of clusters is set to 4.
cut<- cutree(hclust_res, k = 4)
rect.hclust(hclust_res , k = 4, border = 2:6)
```

## Merge frequency matrix

Merge the frequency matrix by calculating the difference between gain frequency 
and loss frequency per interval (gain-loss)

```{r}
diff_mat <- freq_mat[,1:3106]-freq_mat[,3107:6212]
```

Sort the merged matrix by clustering membership 

```{r}
sort_idx <- order(cut)
cut <- cut[sort_idx]
diff_mat <- diff_mat[sort_idx,]
```

## Get metadata (label, sample number)

From the `meta` slot of the object

```{r}
meta <- freq_pgxmatrix$meta[sort_idx,]
```

## Plot heatmap

Plot a heatmap to show the merged matrix. The color in the rowside shows cluster membership calculated by the original frequency matrix   

```{r fig.width=10, fig.height=5}
library("RColorBrewer")
library('pheatmap')
rownames(diff_mat) <- paste(meta[,1], paste0("(",meta[,3],")"),meta[,2])

col <- colorRampPalette(brewer.pal(10, "RdYlBu"))(256)
col_2 <- brewer.pal(n = 8, name = 'Dark2')
parlength <- 100
myBreaks <- c(seq(min(diff_mat), 0, length.out=ceiling(parlength/2) + 1), 
              seq(max(diff_mat)/parlength, max(diff_mat), length.out=floor(parlength/2)))

annotation_row <- data.frame(cluster=factor(cut))
annotation_col <- data.frame(chr  = factor(substring(colnames(diff_mat),1,
                                                    last=regexpr("\\.", colnames(diff_mat))-1),
                                          levels = c(gsub('^','X',seq(1,22)), 'X','Y')))
rownames(annotation_col) <- colnames(diff_mat)
rownames(annotation_row) <- rownames(diff_mat)

pheatmap(as.matrix(diff_mat), scale = "none",cluster_cols = FALSE, cluster_rows = FALSE,width = 8,height = 10,cellwidth=0.1,breaks=myBreaks,show_colnames=FALSE ,
         annotation_row = annotation_row,annotation_col = annotation_col,annotation_legend=TRUE)
```

# Other functions

## `pgxCount` function

The parameter of this function:

* `filters`: A single or a comma-concatenated list of identifiers such as c("NCIT:C7376","pgx:icdom-98353")

This function returns the number of samples for every filter in Progenetix database 
by using `count` method in `collations` service.

```{r}
pgxCount(filters = code)
```

In the returned result, the third column is the number of all the samples of the code and its child terms. 
The fourth column is the number of samples for the exact code matches.

# Session Info

```{r echo = FALSE}
sessionInfo()
```

